let isResizing = false;
let currentTh;
let startX;
let startWidth;
const offset = 8;


// Change selected Tab and open it
// ================================================================================
function openTab(evt, tabName) {
    // Declare all variables
    var i, tabcontent, tabCommand, tablinks, idCommand;

    // Get all elements with class="tabcontent" and hide them
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
      tabcontent[i].style.display = "none";
    }

    // Get all elements with class="tabCommand" and hide them
    idCommand = `cmd${tabName}`;
    tabCommand = document.getElementsByClassName("tabCommand");
    for (i = 0; i < tabCommand.length; i++) {
      tabCommand[i].style.display = "none";
    }

    // Get all elements with class="tablinks" and remove the class "active"
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" active", "");
    }

    // Show the current tab, and add an "active" class to the button that opened the tab
    document.getElementById(tabName).style.display = "block";
    document.getElementById(idCommand).style.display = "block";
    evt.currentTarget.className += " active";
}


function checkTable() {
  if (window.myTables == undefined) return;
  getAllTablesData();
  if (window.myData == undefined) return;
  // Search all tables definition
  for (let [indexTab, tab] of window.myTables.entries()) {
    if (tab.name == undefined) continue;
    if (tab.columnList == undefined) continue;
    if (tab.check == undefined) continue;
    if (tab.check.length < 1) continue;
    // Get table data for table definition
    const tabData = document.querySelector(`tbody[id="${tab.name}"]`);
    if (tabData == undefined) continue;
    // Search all sets of checks from each table
    for (let [indexCheck, ch] of tab.check.entries()) {
      if (ch.in == undefined) continue;
      if (ch.out == undefined) continue;
      if (ch.in.length < 1) continue;
      // Search all lines of data
      for (const [indexRow, row] of Array.from(tabData.rows).entries()) {
        // console.log(row);
        // continue;
        let val = [];
        // Search all in rules of each check
        for (let [indexCh, chi] of ch.in.entries()) {
          // Get data from column to check
          let colDataObj = row.querySelector(`.${chi.col}`);
          let colData = colDataObj.value;
          // Get column definition
          const colDef = tab.columnList.find(element => element.name === chi.col);
          if (colDef == undefined) {
            writeMsg(`Error on Check rule over column not defined (${chi.col})`);
            val.push(false);
          }
          // Treat line break in column's data
          if (colDef.type == window.TYPE_TEXT_LINES) if (colData.includes('\n')) colData = colData.replace(/(?:\r\n|\r|\n)/g, '\\n');
          if (colDef.type == window.TYPE_CHECK) colData=colDataObj.checked;
          // Initiate test
          let test = '';
          let result = false;
          let allColumn = [];
          let countRepeat = 0;
          // console.log('Chi.col=', chi.col, ' :: Column: ', colData);
          switch(chi.check) {
            case window.CHECK_EMPTY:
              test = `'${colData}' == ''`;
              break;
            case window.CHECK_NOT_EMPTY:
              test = `'${colData}' !== ''`;
              break;
            case window.CHECK_CHECKED:
              test = `${colData}`;
              // test = `${colData.checked}`;
              break;
            case window.CHECK_NOT_CHECKED:
              test = `${!colData}`;
              // test = `${!colData.checked}`;
              break;
            case window.CHECK_VALUE:
              if ((window.TEST.length - 1) < chi.test) break;
              test = `${parseInt(colData)} ${window.TEST[chi.test]} ${parseInt(chi.val)}`;
              // console.log('VALUE test: ', test);
              break;
            case window.CHECK_REPEAT:
            // case window.CHECK_NO_REPEAT:
              allColumn = [];
              for (let row of tabData.rows) {
                const cell = row.querySelector(`.${chi.col}`);
                if (cell == undefined) continue;
                if (cell.type == 'checkbox') allColumn.push(cell.checked);
                else allColumn.push(cell.value);
              }
              countRepeat = allColumn.reduce((count, item) => item === colData?count+1:count, 0);
              // console.log(`Number of existence of ${colData} = ${countRepeat}`);
              test = `${countRepeat} > 1`;
              break;
            case window.CHECK_NO_REPEAT:
              allColumn = [];
              for (let row of tabData.rows) {
                const cell = row.querySelector(`.${chi.col}`);
                if (cell == undefined) continue;
                if (cell.type == 'checkbox') allColumn.push(cell.checked);
                else allColumn.push(cell.value);
              }
              countRepeat = allColumn.reduce((count, item) => item === colData?count+1:count, 0);
              // console.log(`Number of existence of ${colData} = ${countRepeat}`);
              test = `${countRepeat} < 2`;
              break;
          } // Switch chi.check
          if (test === '') {
            console.log(`Empty test ${indexCh} of check ${indexCheck} of table ${tab.name}`);
            console.log(`\tColumn name=${chi.col} :: value=${colData} :: Condition: ${JSON.stringify(chi)}`);
            continue;
          }
          // console.log('Check Test: ', test);
          result = eval(test);
          val.push(result);
        } // Search all in rules of each check
        let colOutObj = row.querySelector(`.${ch.out.col}`);
        if (val.includes(false)) {
          colOutObj.checked = false;
        } else {
          colOutObj.checked = true;
        }
        if (colOutObj.checked && ch.out.change == window.COLOR_ON_TRUE) colOutObj.parentNode.style.backgroundColor = ch.out.color;
        else if (!colOutObj.checked && ch.out.change == window.COLOR_ON_FALSE) colOutObj.parentNode.style.backgroundColor = ch.out.color;
        else colOutObj.parentNode.style.backgroundColor = 'transparent';
      } // Search all lines of data
    } // Search all sets of checks from each table
    if(tab.total == undefined) continue;
    let totals = [];
    for (let tot of tab.total) {
      let iTot = {};
      let values = [];
      const colDef = tab.columnList.find(element => element.name === tot);
      if (colDef == undefined) {
        writeMsg(`Error on Total over column not defined (${tot})`);
        continue;
      }
      for (let row of tabData.rows) {
        let colTot = row.querySelector(`.${tot}`);
        if (colTot.type == 'checkbox') values.push(colTot.checked);
        else values.push(colTot.value);
      }
      if (colDef.type == window.TYPE_CHECK) iTot[tot] = values.reduce((sum, currentVal) => {return (sum && currentVal);}, true);
      else iTot[tot] = values.reduce((sum, currentVal) => {return (parseFloat(sum) + parseFloat(currentVal));}, 0);
      totals.push(iTot);
    }
    window.myData.find(element => element.table == tab.name).total = totals;
    // Write totals to environment objects if exist
    for (let tot of totals) {
      const key = Object.keys(tot)[0];
      const result = document.querySelector(`#${tab.name}-total-${key}`);
      if (result == undefined) continue;
      if (result.type == 'checkbox') result.checked = tot[key];
      else result.value = tot[key];
    }
  } // Search all tables definition
}

// Action for New Row button
// ================================================================================
function newRow(evt) {
  // Get table id
  const xtTabName = evt.target.parentNode.getAttribute("name");
  if (xtTabName === undefined) return;
  // Get Lists from Data
  let xtDtLists = [];
  // const xtDtLists = window.myData.find(element => element.table === xtTabName)?.lists;
  const xtLists = window.myData.find(element => element.table === xtTabName)?.lists;
  for (let list of xtLists) {
    let lst = document.createElement('datalist');
    lst.id = list.name;
    for (let item of list.list) {
      let opt = document.createElement('option');
      opt.value = item;
      lst.appendChild(opt);
    }
    xtDtLists.push(lst);
  }
  // Get tbody of table (by id)
  const tBody = document.getElementById(xtTabName);
  if (tBody === undefined) return;
  const xtNextRow = parseInt(tBody.rows.length)+1;
  // Create tag for new line
  const xtTab = window.myTables.find(element => element.name === xtTabName);
  if (xtTab === undefined) return;
  if (xtTab.columnList.length < 1) return;
  const newLine = document.createElement('tr');
  for (let col of xtTab.columnList) {
    const xtCol = document.createElement('td');
    switch(col.type) {
      case window.TYPE_TEXT:
        xtCol.innerHTML=`<input type="text" class="${col.name}" value="${col.autoincrement?xtNextRow:''}" placeholder="${col.default}" title="${col.description}"${!col.writable?' readonly':''}>`;
        break;
      case window.TYPE_TEXT_LINES:
        xtCol.innerHTML=`<textarea type="text" class="${col.name}" rows="${col.rows}" cols="${col.cols}" placeholder="${col.default}" title="${col.description}"${!col.writable?' readonly':''}></textarea>`;
        break;
      case window.TYPE_CHECK:
        xtCol.innerHTML=`<input type="checkbox" class="${col.name}" title="${col.description}"${col.default?' checked':''}${!col.writable?' onclick="return false;"':''}>`;
        break;
      case window.TYPE_LIST:
        const xtTmpList = xtDtLists.find(element => element.id === col.source);
        if (xtTmpList === undefined) continue;
        xtCol.innerHTML=`<input type="text" class="${col.name}" list="${xtTmpList.id === undefined?'':xtTmpList.id}" placeholder="${col.default}" value="" title="${col.description}"${!col.writable?' readonly':''}>`;
        xtCol.appendChild(xtTmpList);
        break;
      case window.TYPE_COMMANDS:
        let bt01 = document.createElement('button');
        let bt02 = document.createElement('button');
        let bt03 = document.createElement('button');
        let img01 = document.createElement('img');
        let img02 = document.createElement('img');
        let img03 = document.createElement('img');
        bt01.className = "CmdUp";
        img01.src = "images/arrow-up.png";
        img01.alt = "Move Line Up";
        bt02.className = "CmdDwn";
        img02.src = "images/arrow-down.png";
        img02.alt = "Move Line Down";
        bt03.className = "CmdDel";
        img03.src = "images/delete.webp";
        img03.alt = "Delete Line";
        bt01.alt = "Move Line Up";
        bt01.addEventListener('click', (event) => {moveUp(newLine);});
        bt01.appendChild(img01);
        xtCol.appendChild(bt01);
        bt02.appendChild(img02);
        bt02.addEventListener('click', (event) => {moveDwn(newLine);});
        xtCol.appendChild(bt02);
        bt03.appendChild(img03);
        bt03.addEventListener('click', (event) => {deleteRow(newLine);});
        xtCol.appendChild(bt03);
        break;
    }
    newLine.appendChild(xtCol);
  }
  // Add new line to table body
  tBody.appendChild(newLine);
}


//   // Action for 
//   // ================================================================================
//   // function updateTdColor(checkbox) {
//   //   const td = checkbox.parentElement;
//   //   if (checkbox.checked) {
//   //     td.style.backgroundColor = "red";
//   //   } else {
//   //     td.style.removeProperty('backgroundColor');
//   //   }
//   // }
  
// ================================================================================
/**
 * Action for Move Up button
 * @param {row} row - row object (<tr>) to move
 * @returns {null}
 */
function moveUp(row) {
  if (!row) {
    writeMsg('Can Not Move Up!');
    return;
  }
  event.preventDefault();
  const previousRow = row.previousElementSibling;
  if (previousRow) {
    const line1 = row.cells[0].querySelector('input').value;
    const line2 = previousRow.cells[0].querySelector('input').value;
    row.cells[0].querySelector('input').value = line2;
    previousRow.cells[0].querySelector('input').value = line1;
    row.parentElement.insertBefore(row, previousRow);
  } else writeMsg('Can Not Move Up!');
}

// ================================================================================
/**
 * Action for Move Down button
 * @param {row} row - row object (<tr>) to move
 * @returns 
 */
function moveDwn(row) {
  if (!row) {
    writeMsg('Can Not Move Down!');
    return;
  }
  event.preventDefault();
  const nextRow = row.nextElementSibling;
  if (nextRow) {
    const line1 = row.cells[0].querySelector('input').value;
    const line2 = nextRow.cells[0].querySelector('input').value;
    row.cells[0].querySelector('input').value = line2;
    nextRow.cells[0].querySelector('input').value = line1;
    row.parentElement.insertBefore(nextRow, row);
  } else writeMsg('Can Not Move Down!');
}

// ================================================================================
/**
 * Action for Delete Row button
 * @param {row} row - row object (<tr>) to delete
 * @returns {null}
 */
function deleteRow(row) {
  if (!row) {
    writeMsg('Can Not Delete Row!');
    return;
  }
  event.preventDefault();
  const xtTab = row.parentNode;
  if (xtTab === undefined) return;
  const xtTabDef = window.myTables.find(element => element.name === xtTab.id);
  if (xtTabDef === undefined) return;
  const xtColDef = xtTabDef.columnList.find(element => element.autoincrement === true);
  if (xtColDef === undefined) {
    row.remove();
    return;
  }
  const xtColRowNum = xtColDef.name;
  if (xtColRowNum === undefined) {
    row.remove();
    return;
  }
  const xtNumDel = row.querySelector(`.${xtColRowNum}`).value;
  if (xtNumDel === undefined) return;
  row.remove();
  if (xtNumDel <= xtTab.rows.length) {
    for (let i=xtNumDel-1; i<xtTab.rows.length; i++) {
      xtTab.rows[i].querySelector(`.${xtColRowNum}`).value = parseInt(i)+1;
    }
  }
}

  
// ================================================================================
/**
 * Write Text in Output Box
 * @param {string} txt 
 * @returns {null}
*/
function writeMsg(txt) {
  if (!txt) return;
  const output = document.getElementById('output');
  output.textContent = txt;
}

/**
 * Clean Text of Output Box
 * @returns {null}
*/
function cleanMsg() {
  const output = document.getElementById('output');
  output.textContent = "";
}

/**
 * Append Text to Output Box
 * @param {string} txt 
 * @returns {null}
*/
function appendMsg(txt) {
  if (!txt) return;
  const output = document.getElementById('output');
  output.textContent += txt;
}


/**
 * Implement auto filter in table
 * @param {string} tableName 
 * @param {Int16Array} columnIndex 
 * @returns {null}
*/
// ================================================================================
function filterTable(tableName, columnIndex) {
  const tBody = document.querySelector(`#${tableName}`);
  if (tBody === undefined) return;
  const filterValue = tBody.parentNode.querySelector('thead').getElementsByTagName('th')[columnIndex].querySelector('input').value.toLowerCase();
  for (let line of tBody.rows) {
    let cellFilter = line.getElementsByTagName('td')[columnIndex]?.getElementsByTagName('input')[0];
    if (cellFilter === undefined) cellFilter = line.getElementsByTagName('td')[columnIndex]?.getElementsByTagName('textarea')[0];
    if (cellFilter === undefined) continue;
    if (cellFilter) {
      const cellValue = cellFilter.value.toLowerCase();
      line.style.display = cellValue.includes(filterValue)?'':'none';
    }
  }
}

/**
 * Set up all table structures
 * @returns {null}
 */
function defineStructures() {
  // console.log('INICIO');
  if (window.myTables == undefined) return;
  for (let tab of window.myTables) {
    const xtTarget = document.querySelector(`.tabcontent[name="${tab.name}"]`);
    if (xtTarget == undefined) continue;
    const xtTitle = document.createElement('h3');
    const xtOuter = document.createElement('div');
    const xtContain = document.createElement('div');
    const xtTab = document.createElement('table');
    const xtTHead = document.createElement('thead');
    const xtTBody = document.createElement('tbody');
    const xtTr = document.createElement('tr');
    xtTitle.innerHTML = tab.title;
    xtTarget.appendChild(xtTitle);
    xtOuter.className = 'table-outer-container';
    xtContain.className = 'table-container';
    let iXtCol = 0;
    for (let col of tab.columnList) {
      const xtCol = document.createElement('th');
      xtCol.name = col.name;
      xtCol.title = col.description;
      xtCol.innerHTML = col.title;
      if (col.filtered) {
        const xtFilter = `<br><input type="text" placeholder="Filter" oninput="filterTable('${tab.name}', ${iXtCol})">`;
        xtCol.innerHTML += xtFilter;
      }
      xtTHead.appendChild(xtCol);
      ++iXtCol;
    }
    xtTBody.id = tab.name;
    xtTBody.name = tab.name;
    xtTBody.className = 'scrollable';
    xtTHead.appendChild(xtTr);
    xtTab.appendChild(xtTHead);
    xtTab.appendChild(xtTBody);
    xtContain.appendChild(xtTab);
    xtOuter.appendChild(xtContain);
    xtTarget.appendChild(xtOuter);
  }
  // Deals with mouse events to implement table column resize
  const tables = document.querySelectorAll('table');
  tables.forEach(table => {
    table.addEventListener("mousemove", (e) => {
      if (isResizing) return;
      const th = e.target.closest("th");
      if (!th) return;
      const rect = th.getBoundingClientRect();
      if (e.clientX - rect.left < offset || rect.right - e.clientX < offset) {
        th.style.cursor = "col-resize";
      } else {
        th.style.cursor = "";
      }
    });
    table.addEventListener("mousedown", (e) => {
      const cell = e.target.closest("th");
      if (cell == undefined) return;
      if (cell.style.cursor !== "col-resize") return;
      isResizing = true;
      currentTh = e.target.closest("th");
      startX = e.clientX;
      startWidth = currentTh.offsetWidth;
      document.addEventListener("mousemove", resizeColumn);
      document.addEventListener("mouseup", stopResize);
    });
  });
}

/**
 * Loads data to all table structures
 * @returns {null} - No return
 */
function loadData() {
  if (window.myTables == undefined) return;
  if (window.myData == undefined) return;
  if (window.myData.length < 1) return;
  // console.log('DADOS: ', window.myData);
  // console.log('DADOS');
  for (let tab of window.myTables) {
    const xtTarget = document.querySelector(`.tabcontent[name="${tab.name}"]`);
    const xtTBody = document.querySelector(`#${tab.name}`);
    const xtDefData = window.myData.find(element => element.table === tab.name);
    if (xtTarget == undefined) continue;
    if (xtTBody == undefined) continue;
    if (xtDefData == undefined) continue;
    const xtData = xtDefData.data;
    if (xtData == undefined) continue;
    const xtLists = xtDefData.lists;
    let xtDtList = [];
    // console.log('Table: ', tab.name, ' = ', xtDefData.table);
    // console.log('Data: ', xtData);
    // Create datalists
    for (let list of xtLists) {
      // console.log('Lista: ', list);
      let xtList = document.createElement('datalist');
      xtList.id = list.name;
      for (let item of list.list) {
        // console.log(item);
        let xtOpt = document.createElement('option');
        xtOpt.value = item;
        xtList.appendChild(xtOpt);
      }
      // console.log('Lst: ', xtList);
      xtDtList.push(xtList);
    }
    // console.log('Lst: ', xtDtList[0]);
    const xtNewTBody = document.createElement('tbody');
    xtNewTBody.id = tab.name;
    xtNewTBody.name = tab.name;
    xtNewTBody.className = 'scrollable';
    let iXtCol = 0;
    for (let line of xtData) {
      // console.log('Line: ', line);
      const xtLine = document.createElement('tr');
      ++iXtCol;
      for (let col of tab.columnList) {
        // console.log('Col=', col.name, ' :: Value=', line[col.name]);
        const xtCol = document.createElement('td');
        switch(col.type) {
          case window.TYPE_TEXT:
            xtCol.innerHTML=`<input type="text" class="${col.name}" value="${col.autoincrement?iXtCol:line[col.name]}" placeholder="${col.default}" title="${col.description}"${col.writable?'':' readonly'}>`;
            break;
          case window.TYPE_TEXT_LINES:
            xtCol.innerHTML=`<textarea type="text" class="${col.name}" rows="${col.rows}" cols="${col.cols}" placeholder="${col.default}" title="${col.description}"${col.writable?'':' readonly'}>${line[col.name]}</textarea>`;
            break;
          case window.TYPE_CHECK:
            xtCol.innerHTML=`<input type="checkbox" class="${col.name}" title="${col.description}"${line[col.name]?' checked':''}${col.writable?'':' onclick="return false;"'}>`;
            break;
          case window.TYPE_LIST:
            const xtTmpList = xtDtList.find(element => element.id === col.source);
            if (xtTmpList === undefined) continue;
            xtCol.innerHTML=`<input type="text" class="${col.name}" list="${xtTmpList.id === undefined?'':xtTmpList.id}" placeholder="${col.default}" value="${line[col.name]}" title="${col.description}"${col.writable?'':' readonly'}>`;
            xtCol.appendChild(xtTmpList);
            break;
          case window.TYPE_COMMANDS:
            let bt01 = document.createElement('button');
            let bt02 = document.createElement('button');
            let bt03 = document.createElement('button');
            let img01 = document.createElement('img');
            let img02 = document.createElement('img');
            let img03 = document.createElement('img');
            bt01.className = "CmdUp";
            img01.src = "images/arrow-up.png";
            img01.alt = "Move Line Up";
            bt02.className = "CmdDwn";
            img02.src = "images/arrow-down.png";
            img02.alt = "Move Line Down";
            bt03.className = "CmdDel";
            img03.src = "images/delete.webp";
            img03.alt = "Delete Line";
            bt01.alt = "Move Line Up";
            bt01.addEventListener('click', (event) => {moveUp(xtLine);});
            bt01.appendChild(img01);
            xtCol.appendChild(bt01);
            bt02.appendChild(img02);
            bt02.addEventListener('click', (event) => {moveDwn(xtLine);});
            xtCol.appendChild(bt02);
            bt03.appendChild(img03);
            bt03.addEventListener('click', (event) => {deleteRow(xtLine);});
            xtCol.appendChild(bt03);
            break;
        }
        xtLine.appendChild(xtCol);
      }
      xtNewTBody.appendChild(xtLine);
    }
    xtTBody.parentNode.replaceChild(xtNewTBody, xtTBody);
    xtNewTBody.addEventListener('click', async() => {checkTable();});
    xtNewTBody.addEventListener('change', async() => {checkTable();});
    xtNewTBody.click();
  }
}

/**
 * Loads all table structures with default data
 * @returns {null} - No return
 */
function startDefaultData() {
  if (window.myTables === undefined) return;
  if (window.myDefData === undefined) return;
  window.myData = window.myDefData;
  // console.log(window.myData);
  loadData();
}

/**
 * Updates the Data Array (window.myData) from All Tables
 * @returns {null}
 */
function getAllTablesData() {
  if (window.myTables == undefined) throw new Error('No table definition found!');
  cleanMsg();
  for (let tabDef of window.myTables) {
    if (tabDef.name == undefined) throw new Error('Found table definition without name!');
    if (tabDef.columnList == undefined) throw new Error('Found table definition without data columns definition!');
    if (tabDef.columnList.length < 1) throw new Error('Found table definition without any data column definition!');
    const xtTBody = document.querySelector(`#${tabDef.name}`);
    if (xtTBody == undefined) {
      // throw new Error(`Table "${tabDef.name}" not found in app!`);
      appendMsg(`Table "${tabDef.name}" not found in app!`);
      continue;
    }
    if (xtTBody.rows == undefined) {
      // throw new Error(`Table "${tabDef.name}" is presented in app but with no rows!`);
      // appendMsg(`Table "${tabDef.name}" is presented in app but with no rows!`);
      continue;
    }
    if (xtTBody.rows.length < 1) {
      // throw new Error(`Table "${tabDef.name}" is presented in app but with no rows!`);
      // appendMsg(`Table "${tabDef.name}" is presented in app but with no rows!`);
      continue;
    }
    let rowList = [];
    for (let row of xtTBody.rows) {
      const rowItem = {};
      for (let col of tabDef.columnList) {
        if (col.type === window.TYPE_COMMANDS) continue;
        const xtCol = row.querySelector(`.${col.name}`);
        if (xtCol == undefined) {throw new Error(`Table "${tabDef.name}" is presented in app but without the column ${col.name}!`);}
        if (col.type === window.TYPE_CHECK) {
          rowItem[col.name] = xtCol.checked;
        } else if (col.type === window.TYPE_LIST) rowItem[col.name] = xtCol.value;
        else rowItem[col.name] = xtCol.value;
      }
      rowList.push(rowItem);
    }
    let foundTab = false;
    for (let tabData of window.myData) {
      if (tabData.table === tabDef.name) {
        tabData.data = rowList;
        foundTab = true;
      } else continue;
    }
    if (!foundTab) {
      let lsts = [];
      for (const dl of xtTBody.querySelectorAll('datalist')) {
        let lst = {name: dl.id};
        let items = [];
        for (let opt of dl.options) items.push(opt.value);
        lst["list"] = items;
        lsts.push(lst);
      }
      const newTab = {
        table: tabDef.name,
        data: rowList,
        lists: lsts
      };
      window.myData.push(newTab);
    }
  }
  // console.log(window.myData);
}

/**
 * Resize table column (used by mouse events)
 * @param {*} e - event from where this function was called
 * @returns {null}
 */
function resizeColumn(e) {
  if (!isResizing) return;
  const newWidth = startWidth + (e.clientX - startX);
  currentTh.style.width = `${newWidth}px`;
}

/**
 * Stop the action of table column resize
 */
function stopResize() {
  isResizing = false;
  document.removeEventListener("mousemove", resizeColumn);
  document.removeEventListener("mouseup", stopResize);
}
